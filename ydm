#!/usr/bin/env bash
usage="ydm [OPTION...] URL ARTIST - TITLE"
doc="
This script post-processes the raw model output files generated from the
GFDL dry core model. Needs to be supplied with a source and destination directory.

This script downloads, normalizes, and tags audio from arbitrary youtube
videos. It performs the following 3 steps:

* Downloads youtube audio from URL into the native format with the highest
  bitrate -- usually an OOG (webm) file.
* Normalizes the audio volume and re-compresses into an AAC (m4a) file -- AAC
  is used because it matches the compression of mp3 but with much improved
  audio quality for marginal bitrates.
* Tags the audio based on the ARTIST and TITLE. The tagging script does
  various fuzzy searching things to get the album title, album artwork,
  earliest release year, and album genre(s).

Usage

  $usage

Required arguments

  URL     The youtube URL. Must begin with 'http'.
  ARTIST  The artist name. For the tagging step to work, must be separated
          from TITLE with a dash '-' surrounded by whitespace.
  TITLE   The song name. The file will be saved as 'ARTIST - TITLE.m4a' or
          'ARTIST - TITLE.mp3' depending on whether '-3' was passed.

Optional arguments

  -h|--help              Print this message.
  -3|--mp3               Save as MP3 instead of M4A.
  -4|--m4a               Save as M4A. This is the default.
  -q|--quick             Skip the tagging step.
  -Q|--very-quick        Skip the volume normalization and tagging steps.
  -cl|--classical        Download to a separate classical folder in the same
                         location as the directory shown in './config'.
  -c=N|--cut-leading=N   Trims the leading N seconds.
  -C=N|--cut-trailing=N  Trims the trailing N seconds.
  -*                     Remaining flags passed to ydm-metadata.
"
# Helper functions
# NOTE: Could also use afinfo for this part
# let bits=$(afinfo "$path" | grep 'bit rate' | tr -dc '[0-9]')/1000
bitrate() {
  ffmpeg -i "$1" -hide_banner 2>&1 | cat | grep 'bitrate' | cut -d, -f3 | tr -dc '[0-9]'
}
raise() {
  echo "Usage: $usage"
  echo "Error: $@"
  exit 1
}
# Parse input
mp3=false   # mp3 or m4a by default?
quick=0     # 1 means skip metadata, 2 means skip normalization
metadata=true   # by default, retrieve metadata and noarmalize
classical=false # different folder for classical music
normflags="-t -23" # normalize to default of -23
$mp3 && ext_new="mp3" || ext_new="m4a"
while [ $# -gt 0 ]; do
  case $1 in
    -h|--help)       echo "$doc" && exit 0 ;;
    -3|--mp3)        mp3=true  ;;
    -4|--m4a)        mp3=false ;;
    -q|--quick)      quick=1 ;;
    -Q|--very-quick) quick=2 ;;
    -cl|--classical) classical=true; ;;
    -c=*|--cut-leading)  lead=${1#*=} ;;
    -C=*|--cut-trailing) trail=${1#*=} ;;
    -[-a-zA-Z0-9]*)  metaflags+="$1" ;;
    http*) url="$1" ;;
    *)     name+=" $1" ;;
  esac
  shift
done

#-----------------------------------------------------------------------------#
# Initial stuff
#-----------------------------------------------------------------------------#
# 'Extra' arguments for trimming time; can be passed to ffmpeg-normalize
# See this link for trimming: https://superuser.com/questions/258032/is-it-possible-to-use-ffmpeg-to-trim-off-x-seconds-from-the-beginning-of-a-video
trimflag="-e=" # open
if [ -n $lead ]; then
  echo "Trimming first $lead seconds."
  trimflag+="-ss $lead "
fi
if [ -n $trail ]; then
  echo "Trimming last $trail seconds."
  trimflag+="-sseof $trail "
fi

# Trim trialing spaces for filenames
name="${name# }"
name="${name% }"
[ -n "$url" ] || raise "Must supply URL."
echo "URL: $url"
[ -n "$name" ] || raise "Must supply artist and title."
echo "Name: \"$name\""

# Download directory
# Note 'cut' will automatically trim leading/trailing whitespace it seems
config=$(dirname $(realpath $0))/config
[ -r "$config" ] || raise "Config file \"$config\" not found."
directory="$(cat "$config" | grep "directory" | cut -s -d '=' -f 2 | xargs)"
directory="${directory/"~"/$HOME}" # don't expand spaces, but expand ~
directory="${directory%/}" # trim trailing slash if present
$classical && directory="${directory%/*}/classical"
rejects="$(cat "$config" | grep "rejects" | cut -s -d '=' -f 2 | xargs)"
rejects="${rejects/"~"/$HOME}"
rejects="${rejects%/}"
[ -n "$directory" ] || raise "Output directory must be declared in the \"$config\" file with 'directory=DIRECTORY'."
[ -d "$directory" ] || raise "Output directory \"$directory\" does not exist or is not a directory."

# A few basic settings
# TODO: Support for downloading entire playlists or albums
path_template="$directory/$name-download.%(ext)s" # see youtube-dl help info; just picks whatever extension
path_normalized="$directory/$name-normalized.$ext_new"
path_intermediate="$directory/$name-normalized.wav" # sometimes unused
path_new="$directory/$name.$ext_new"
flags="-q -f bestaudio --no-playlist"

# Optionally confirm
if [ -n "$rejects" ] && compgen -G "$rejects/$name.*" &>/dev/null; then
  while true; do
    read -r -p "Warning: File is present in \"rejects\" folder. Are you sure you want to download it? ([y]/n) " response
    [ -n "$response" ] && [[ ! "$response" =~  ^[NnYy]$ ]] && continue # invalid
    [[ "$response" =~ ^[Nn]$ ]] && exit # answer is either yes, no, or blank (i.e. yes)
    break
  done
fi

#------------------------------------------------------------------------------#
# Download, using youtube-dl
#------------------------------------------------------------------------------#
echo "Determining filetype."
path="$(youtube-dl --get-filename $flags "$url" -o "$path_template")" # no playlist, in case user provides playlist URL
[ -n "$path" ] || raise "Download failed."
ext="${path##*.}"
echo "Downloading."
youtube-dl $flags "$url" -o "$path_template" # no playlist, in case user provides playlist URL
[ $? -eq 0 ] || raise "Download failed."
[ $quick -ge 2 ] && exit 0

#------------------------------------------------------------------------------#
# Normalize audio and re-compress into AAC
#------------------------------------------------------------------------------#
# Get bitrate
# * The units are Loudness Units Relative to Full Scale.
#   Refers to the target average loudness units for track; this
#   will prevent clipping of sounds up to 26dB above this average.
#   See: https://www.pro-tools-expert.com/home-page/2016/9/6/video-mastering-using-lufs
# * Note default iTunes default bitrate is 256kbs. This step will save
#   file with output bitrate roughly matching original bitrate. Save into m4a
#   because it is better, more efficient format than mp3.
# WARNING: For some reason ffmpeg-normalize sometimes elevates the bitrate by
# a ton, while simple ffmpeg command (e.g. ffmpeg -i file1.m4a -c:a libfdk_aac file2.m4a)
# does not change the bitrate much. So manually specify output bitrate.
bitrate=$(bitrate "$path")
echo "Bitrate: ${bitrate}kbps"
bitrate=$((bitrate*3/2))

# Save to m4a, uses highest quality encoder
if ! $mp3; then
  echo "Normalizing volume, outputing to m4a."
  ffmpeg-normalize "$path" $normflags "$trimflag" -f -c:a libfdk_aac -b:a ${bitrate}k -o "$path_normalized"
  # ffmpeg-normalize $normflags "$trimflag" -f -c:a libfdk_aac -o "$path_normalized" "$path"
  # ffmpeg-normalize "$path" $normflags "$trimflag" -f -o "${path_normalized%.*}.wav" # repeat, uncompressed
  [ $? -eq 0 ] || raise "Normalization failed."
# Save to mp3
# TODO: Fix this, tried with and without intermediary but still fails
else
  echo "Normalizing volume, outputing to mp3."
  ffmpeg-normalize "$path" $normflags "$trimflag" -f -c:a libmp3lame -b:a ${bitrate}k -o "$path_normalized"
  # echo "Generating intermediate file."
  # ffmpeg-normalize "$path" -v -f -o "$path_intermediate"
  # ffmpeg -y -i "$path_intermediate" -c:a libmp3lame "$path_normalized"
  [ $? -eq 0 ] || raise "Normalization failed."
fi

# Cleanup
echo "Bitrate: ${bitrate}kbps"
rm "$path"
mv "$path_normalized" "$path_new"
[ $quick -ge 1 ] && exit 0

#------------------------------------------------------------------------------#
# Change metadata using python function
#------------------------------------------------------------------------------#
echo "Adding metadata."
ydm-metadata $metaflags --url "$url" "$path_new"
[ $? -eq 0 ] || raise "Metadata script failed."
