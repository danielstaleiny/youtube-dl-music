#!/usr/bin/env bash
usage="ydm [OPTION...] URL ARTIST - TITLE"
doc="
Usage

  $usage

Description

  This script downloads, normalizes, and tags audio from arbitrary youtube
  videos. It performs the following 3 steps:

  * Downloads youtube audio from URL into the native format with the highest
    bitrate -- usually an OOG (webm) file.
  * Normalizes the audio volume and re-compresses into an AAC (m4a) file -- AAC
    is used because it matches the compression of mp3 but with much improved
    audio quality for marginal bitrates.
  * Tags the audio based on the ARTIST and TITLE. The tagging script does
    various fuzzy searching things to get the album title, album artwork,
    earliest release year, and album genre(s).

Required arguments

  URL     The youtube URL. Must begin with 'http'.
  ARTIST  The artist name. For the tagging step to work, must be separated
          from TITLE with a dash '-' surrounded by whitespace.
  TITLE   The song name. The file will be saved as 'ARTIST - TITLE.m4a' or
          'ARTIST - TITLE.mp3' depending on whether '-3' was passed.

Optional arguments

  -h|--help              Print this message.
  -3|--mp3               Save as MP3 instead of M4A.
  -4|--m4a               Save as M4A. This is the default.
  -q|--quick             Skip the tagging step.
  -Q|--very-quick        Skip the volume normalization and tagging steps.
  -cl|--classical        Download to a separate classical folder in the same
                         location as the directory shown in './config'.
  -c=N|--cut-leading=N   Trims the leading N seconds.
  -C=N|--cut-trailing=N  Trims the trailing N seconds.
  -*                     Remaining flags passed to ydm-metadata.
"
# Helper functions
# NOTE: Could also use afinfo for this part
# let bits=$(afinfo "$path" | grep 'bit rate' | tr -dc '[0-9]')/1000
bitrate() {
  ffmpeg -i "$1" -hide_banner 2>&1 | cat | grep 'bitrate' | cut -d, -f3 | tr -dc '[0-9]'
}
raise() {
  echo "Usage: $usage"
  echo "Error: $@"
  exit 1
}
# Parse input
quick=0     # 1 means skip metadata, 2 means skip normalization
metadata=true   # by default, retrieve metadata and noarmalize
classical=false # different folder for classical music
normflags="-t -23" # normalize to default of -23
while [ $# -gt 0 ]; do
  case $1 in
    -h|--help)           echo "$doc" && exit 0 ;;
    -3|--mp3)            mp3=true              ;;
    -4|--m4a)            mp3=false             ;;
    -q|--quick)          quick=1               ;;
    -Q|--very-quick)     quick=2               ;;
    -cl|--classical)     classical=true        ;;
    -c=*|--cut-leading)  lead=${1#*=}          ;;
    -C=*|--cut-trailing) trail=${1#*=}         ;;
    -[-a-zA-Z0-9]*)      metaflags+="$1"       ;;
    http*)               url="$1"              ;;
    *)                   name+=" $1"           ;;
  esac
  shift
done
$classical && metaflags+="--classical"  # override the genre tag

#-----------------------------------------------------------------------------#
# Initial stuff
#-----------------------------------------------------------------------------#
# 'Extra' arguments for trimming time; can be passed to ffmpeg-normalize
# See this link for trimming: https://superuser.com/questions/258032/is-it-possible-to-use-ffmpeg-to-trim-off-x-seconds-from-the-beginning-of-a-video
trimflag="-e=" # open
if [ -n "$lead" ]; then
  echo "Trimming first $lead seconds."
  trimflag+="-ss $lead "
fi
if [ -n "$trail" ]; then
  echo "Trimming last $trail seconds."
  trimflag+="-sseof $trail "
fi

# Trim trialing spaces for filenames
name="${name# }"
name="${name% }"
[ -n "$url" ] || raise "Must supply URL."
echo "URL: $url"
[ -n "$name" ] || raise "Must supply artist and title."
echo "Name: \"$name\""

# Configuration file
config=$(dirname $(realpath $0))/.config
[ -r "$config" ] || raise "Config file \"$config\" not found."

# Download directory
# Note 'cut' will automatically trim leading/trailing whitespace it seems
directory="$(cat "$config" | grep "directory" | cut -s -d '=' -f 2 | xargs)"
directory="${directory/"~"/$HOME}" # don't expand spaces, but expand ~
directory="${directory%/}" # trim trailing slash if present
$classical && directory="${directory%/*}/classical"
[ -n "$directory" ] || raise "Output directory must be declared in the \"$config\" file with 'directory=DIRECTORY'."
[ -d "$directory" ] || raise "Output directory \"$directory\" does not exist or is not a directory."

# MP3 or M4A?
if [ -z "$mp3" ]; then
  mp3="$(cat "$config" | grep "mp3" | cut -s -d '=' -f 2 | tr [A-Z] [a-z] | xargs)"
  [ -n "$mp3" ] || mp3=false
  if ! [[ "$mp3" == "true" || "$mp3" == "false" ]]; then
    raise "Value 'mp3' in .config file must be either 'true' or 'false'."
  fi
fi
$mp3 && ext_new="mp3" || ext_new="m4a"

# A few basic settings
# TODO: Support for downloading entire playlists or albums
path_template="$directory/$name-download.%(ext)s" # see youtube-dl help info; just picks whatever extension
path_normalized="$directory/$name-normalized.$ext_new"
path_intermediate="$directory/$name-normalized.wav" # sometimes unused
path_new="$directory/$name.$ext_new"
flags="-q -f bestaudio --no-playlist"

#------------------------------------------------------------------------------#
# Download, using youtube-dl
#------------------------------------------------------------------------------#
echo "Determining filetype."
path=$(youtube-dl --get-filename $flags "$url" -o "$path_template") # no playlist, in case user provides playlist URL
[ -n "$path" ] || raise "Download failed."
ext="${path##*.}"
echo "Downloading."
youtube-dl $flags "$url" -o "$path_template" # no playlist, in case user provides playlist URL
[ $? -eq 0 ] || raise "Download failed."
[ $quick -ge 2 ] && exit 0

#------------------------------------------------------------------------------#
# Normalize audio and re-compress into AAC
#------------------------------------------------------------------------------#
# Get bitrate
# * The units are Loudness Units Relative to Full Scale.
#   Refers to the target average loudness units for track; this
#   will prevent clipping of sounds up to 26dB above this average.
#   See: https://www.pro-tools-expert.com/home-page/2016/9/6/video-mastering-using-lufs
# * Note default iTunes default bitrate is 256kbs. This step will save
#   file with output bitrate roughly matching original bitrate. Save into m4a
#   because it is better, more efficient format than mp3.
# WARNING: For some reason ffmpeg-normalize sometimes elevates the bitrate by
# a ton, while simple ffmpeg command (e.g. ffmpeg -i file1.m4a -c:a libfdk_aac file2.m4a)
# does not change the bitrate much. So manually specify output bitrate.
bitrate=$(bitrate "$path")
echo "Bitrate: ${bitrate}kbps"
bitrate=$((bitrate*3/2))

# Save to m4a, uses highest quality encoder
if ! $mp3; then
  echo "Normalizing volume and saving to m4a."
  ffmpeg-normalize "$path" $normflags "$trimflag" -f -c:a libfdk_aac -b:a ${bitrate}k -o "$path_normalized"
  [ $? -eq 0 ] || raise "Normalization failed."
# Save to mp3
else
  echo "Normalizing volume and saving to mp3."
  ffmpeg-normalize "$path" $normflags "$trimflag" -f -c:a libmp3lame -b:a ${bitrate}k -o "$path_normalized"
  [ $? -eq 0 ] || raise "Normalization failed."
fi

# Cleanup
echo "Bitrate: ${bitrate}kbps"
rm "$path"
mv "$path_normalized" "$path_new"
[ $quick -ge 1 ] && exit 0

#------------------------------------------------------------------------------#
# Change metadata using python function
#------------------------------------------------------------------------------#
echo "Adding metadata."
ydm-metadata $metaflags --url "$url" "$path_new"
[ $? -eq 0 ] || raise "Metadata script failed."
